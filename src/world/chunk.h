#pragma once

#include "block.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glad/glad.h>
#include <array>
#include <vector>
#include <memory>

// Chunk dimensions
constexpr int CHUNK_WIDTH = 16;
constexpr int CHUNK_HEIGHT = 256;
constexpr int CHUNK_DEPTH = 16;
constexpr int BLOCKS_PER_CHUNK = CHUNK_WIDTH * CHUNK_HEIGHT * CHUNK_DEPTH;

// Chunk coordinate system
struct ChunkCoord {
    int x, z;

    ChunkCoord() : x(0), z(0) {}
    ChunkCoord(int x, int z) : x(x), z(z) {}

    bool operator==(const ChunkCoord& other) const {
        return x == other.x && z == other.z;
    }

    bool operator!=(const ChunkCoord& other) const {
        return !(*this == other);
    }

    bool operator<(const ChunkCoord& other) const {
        if (x != other.x) return x < other.x;
        return z < other.z;
    }

    // Hash function for use in unordered_map
    struct Hash {
        std::size_t operator()(const ChunkCoord& coord) const {
            // Combine hash of x and z coordinates
            return std::hash<int>()(coord.x) ^ (std::hash<int>()(coord.z) << 1);
        }
    };
};

// Chunk state enumeration
enum class ChunkState {
    EMPTY,      // Not allocated
    GENERATING, // Being generated by world generator
    GENERATED,  // Generation complete, ready for meshing
    MESHING,    // Mesh being generated
    READY,      // Ready to render
    UNLOADING   // Being unloaded
};

// Face directions for cube mesh generation
enum class CubeFace {
    FRONT = 0,
    BACK,
    LEFT,
    RIGHT,
    TOP,
    BOTTOM
};

class Chunk {
public:
    Chunk(ChunkCoord coord);
    ~Chunk();

    // Block access methods
    BlockData getBlock(int x, int y, int z) const;
    void setBlock(int x, int y, int z, BlockData block);

    // Safe block access with bounds checking
    BlockData getBlockSafe(int x, int y, int z) const;
    void setBlockSafe(int x, int y, int z, BlockData block);

    // Block access by world coordinates
    BlockData getBlockWorld(int worldX, int worldY, int worldZ) const;
    void setBlockWorld(int worldX, int worldY, int worldZ, BlockData block);

    // Mesh management
    void generateMesh();
    void render(const glm::mat4& view, const glm::mat4& projection);
    void clearMesh();

    // State management
    ChunkState getState() const { return state; }
    void setState(ChunkState newState) { state = newState; }
    bool isReady() const { return state == ChunkState::READY; }
    bool needsRemeshing() const { return meshDirty; }
    void markForRemesh() { meshDirty = true; }

    // Coordinate utilities
    ChunkCoord getCoord() const { return coord; }
    glm::vec3 getWorldPosition() const;
    bool isInBounds(int x, int y, int z) const;

    // Neighbor management (for mesh optimization)
    void setNeighbor(CubeFace face, Chunk* neighbor);
    Chunk* getNeighbor(CubeFace face) const;

    // Face culling optimization
    bool shouldRenderFace(int x, int y, int z, CubeFace face) const;

    // Statistics
    int getVertexCount() const { return vertexCount; }
    int getTriangleCount() const { return vertexCount / 3; }

private:
    // Core data
    ChunkCoord coord;
    ChunkState state;
    std::array<BlockData, BLOCKS_PER_CHUNK> blocks;

    // Neighbor chunks for face culling
    std::array<Chunk*, 6> neighbors;

    // Rendering data
    GLuint VAO, VBO;
    size_t vertexCount;
    bool meshDirty;
    bool hasGeometry;

    // Mesh generation helpers
    void addFace(std::vector<float>& vertices, const glm::vec3& pos,
                 CubeFace face, BlockType blockType);
    void addQuadVertices(std::vector<float>& vertices,
                        const std::array<glm::vec3, 4>& corners,
                        const glm::vec3& normal,
                        const glm::vec2& texCoords);

    // Coordinate conversion
    int getBlockIndex(int x, int y, int z) const;
    glm::vec3 indexToLocal(int index) const;
    glm::vec3 localToWorld(int x, int y, int z) const;

    // Face definition data
    static const std::array<std::array<glm::vec3, 4>, 6> FACE_VERTICES;
    static const std::array<glm::vec3, 6> FACE_NORMALS;

    // OpenGL resource management
    void initializeGL();
    void cleanupGL();
};

// Chunk coordinate utility functions
namespace ChunkUtils {
    // Convert world coordinates to chunk coordinates
    ChunkCoord worldToChunkCoord(int worldX, int worldZ);
    ChunkCoord worldToChunkCoord(const glm::vec3& worldPos);

    // Convert world coordinates to local chunk coordinates
    glm::ivec3 worldToLocal(int worldX, int worldY, int worldZ);
    glm::ivec3 worldToLocal(const glm::vec3& worldPos);

    // Convert chunk coordinates to world position
    glm::vec3 chunkToWorldPos(const ChunkCoord& coord);

    // Distance calculations
    float chunkDistance(const ChunkCoord& a, const ChunkCoord& b);
    float chunkDistanceToPoint(const ChunkCoord& chunk, const glm::vec3& point);

    // Chunk bounds
    bool isValidChunkCoord(int x, int z);
    bool isValidBlockCoord(int x, int y, int z);
}
